// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'plan_type_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$PlanTypeEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(PlanTypeFormDto planType) create,
    required TResult Function(int planTypeId) delete,
    required TResult Function(int planTypeId, int day) deletePlanTypeDay,
    required TResult Function(int id) getPlanType,
    required TResult Function() getPlanTypes,
    required TResult Function(List<int> dietIds, List<int> workoutIds)
        getSelectedDietAndWorkoutPlans,
    required TResult Function(PlanTypeFormDto planType) update,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(PlanTypeFormDto planType)? create,
    TResult? Function(int planTypeId)? delete,
    TResult? Function(int planTypeId, int day)? deletePlanTypeDay,
    TResult? Function(int id)? getPlanType,
    TResult? Function()? getPlanTypes,
    TResult? Function(List<int> dietIds, List<int> workoutIds)?
        getSelectedDietAndWorkoutPlans,
    TResult? Function(PlanTypeFormDto planType)? update,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(PlanTypeFormDto planType)? create,
    TResult Function(int planTypeId)? delete,
    TResult Function(int planTypeId, int day)? deletePlanTypeDay,
    TResult Function(int id)? getPlanType,
    TResult Function()? getPlanTypes,
    TResult Function(List<int> dietIds, List<int> workoutIds)?
        getSelectedDietAndWorkoutPlans,
    TResult Function(PlanTypeFormDto planType)? update,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(Create value) create,
    required TResult Function(Delete value) delete,
    required TResult Function(DeletePlanTypeDay value) deletePlanTypeDay,
    required TResult Function(GetPlanType value) getPlanType,
    required TResult Function(GetPlanTypes value) getPlanTypes,
    required TResult Function(GetSelectedDietAndWorkoutPlans value)
        getSelectedDietAndWorkoutPlans,
    required TResult Function(Update value) update,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(Create value)? create,
    TResult? Function(Delete value)? delete,
    TResult? Function(DeletePlanTypeDay value)? deletePlanTypeDay,
    TResult? Function(GetPlanType value)? getPlanType,
    TResult? Function(GetPlanTypes value)? getPlanTypes,
    TResult? Function(GetSelectedDietAndWorkoutPlans value)?
        getSelectedDietAndWorkoutPlans,
    TResult? Function(Update value)? update,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(Create value)? create,
    TResult Function(Delete value)? delete,
    TResult Function(DeletePlanTypeDay value)? deletePlanTypeDay,
    TResult Function(GetPlanType value)? getPlanType,
    TResult Function(GetPlanTypes value)? getPlanTypes,
    TResult Function(GetSelectedDietAndWorkoutPlans value)?
        getSelectedDietAndWorkoutPlans,
    TResult Function(Update value)? update,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PlanTypeEventCopyWith<$Res> {
  factory $PlanTypeEventCopyWith(
          PlanTypeEvent value, $Res Function(PlanTypeEvent) then) =
      _$PlanTypeEventCopyWithImpl<$Res, PlanTypeEvent>;
}

/// @nodoc
class _$PlanTypeEventCopyWithImpl<$Res, $Val extends PlanTypeEvent>
    implements $PlanTypeEventCopyWith<$Res> {
  _$PlanTypeEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_InitialCopyWith<$Res> {
  factory _$$_InitialCopyWith(
          _$_Initial value, $Res Function(_$_Initial) then) =
      __$$_InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InitialCopyWithImpl<$Res>
    extends _$PlanTypeEventCopyWithImpl<$Res, _$_Initial>
    implements _$$_InitialCopyWith<$Res> {
  __$$_InitialCopyWithImpl(_$_Initial _value, $Res Function(_$_Initial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Initial implements _Initial {
  const _$_Initial();

  @override
  String toString() {
    return 'PlanTypeEvent.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(PlanTypeFormDto planType) create,
    required TResult Function(int planTypeId) delete,
    required TResult Function(int planTypeId, int day) deletePlanTypeDay,
    required TResult Function(int id) getPlanType,
    required TResult Function() getPlanTypes,
    required TResult Function(List<int> dietIds, List<int> workoutIds)
        getSelectedDietAndWorkoutPlans,
    required TResult Function(PlanTypeFormDto planType) update,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(PlanTypeFormDto planType)? create,
    TResult? Function(int planTypeId)? delete,
    TResult? Function(int planTypeId, int day)? deletePlanTypeDay,
    TResult? Function(int id)? getPlanType,
    TResult? Function()? getPlanTypes,
    TResult? Function(List<int> dietIds, List<int> workoutIds)?
        getSelectedDietAndWorkoutPlans,
    TResult? Function(PlanTypeFormDto planType)? update,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(PlanTypeFormDto planType)? create,
    TResult Function(int planTypeId)? delete,
    TResult Function(int planTypeId, int day)? deletePlanTypeDay,
    TResult Function(int id)? getPlanType,
    TResult Function()? getPlanTypes,
    TResult Function(List<int> dietIds, List<int> workoutIds)?
        getSelectedDietAndWorkoutPlans,
    TResult Function(PlanTypeFormDto planType)? update,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(Create value) create,
    required TResult Function(Delete value) delete,
    required TResult Function(DeletePlanTypeDay value) deletePlanTypeDay,
    required TResult Function(GetPlanType value) getPlanType,
    required TResult Function(GetPlanTypes value) getPlanTypes,
    required TResult Function(GetSelectedDietAndWorkoutPlans value)
        getSelectedDietAndWorkoutPlans,
    required TResult Function(Update value) update,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(Create value)? create,
    TResult? Function(Delete value)? delete,
    TResult? Function(DeletePlanTypeDay value)? deletePlanTypeDay,
    TResult? Function(GetPlanType value)? getPlanType,
    TResult? Function(GetPlanTypes value)? getPlanTypes,
    TResult? Function(GetSelectedDietAndWorkoutPlans value)?
        getSelectedDietAndWorkoutPlans,
    TResult? Function(Update value)? update,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(Create value)? create,
    TResult Function(Delete value)? delete,
    TResult Function(DeletePlanTypeDay value)? deletePlanTypeDay,
    TResult Function(GetPlanType value)? getPlanType,
    TResult Function(GetPlanTypes value)? getPlanTypes,
    TResult Function(GetSelectedDietAndWorkoutPlans value)?
        getSelectedDietAndWorkoutPlans,
    TResult Function(Update value)? update,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements PlanTypeEvent {
  const factory _Initial() = _$_Initial;
}

/// @nodoc
abstract class _$$CreateCopyWith<$Res> {
  factory _$$CreateCopyWith(_$Create value, $Res Function(_$Create) then) =
      __$$CreateCopyWithImpl<$Res>;
  @useResult
  $Res call({PlanTypeFormDto planType});

  $PlanTypeFormDtoCopyWith<$Res> get planType;
}

/// @nodoc
class __$$CreateCopyWithImpl<$Res>
    extends _$PlanTypeEventCopyWithImpl<$Res, _$Create>
    implements _$$CreateCopyWith<$Res> {
  __$$CreateCopyWithImpl(_$Create _value, $Res Function(_$Create) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? planType = null,
  }) {
    return _then(_$Create(
      null == planType
          ? _value.planType
          : planType // ignore: cast_nullable_to_non_nullable
              as PlanTypeFormDto,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PlanTypeFormDtoCopyWith<$Res> get planType {
    return $PlanTypeFormDtoCopyWith<$Res>(_value.planType, (value) {
      return _then(_value.copyWith(planType: value));
    });
  }
}

/// @nodoc

class _$Create implements Create {
  const _$Create(this.planType);

  @override
  final PlanTypeFormDto planType;

  @override
  String toString() {
    return 'PlanTypeEvent.create(planType: $planType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Create &&
            (identical(other.planType, planType) ||
                other.planType == planType));
  }

  @override
  int get hashCode => Object.hash(runtimeType, planType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateCopyWith<_$Create> get copyWith =>
      __$$CreateCopyWithImpl<_$Create>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(PlanTypeFormDto planType) create,
    required TResult Function(int planTypeId) delete,
    required TResult Function(int planTypeId, int day) deletePlanTypeDay,
    required TResult Function(int id) getPlanType,
    required TResult Function() getPlanTypes,
    required TResult Function(List<int> dietIds, List<int> workoutIds)
        getSelectedDietAndWorkoutPlans,
    required TResult Function(PlanTypeFormDto planType) update,
  }) {
    return create(planType);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(PlanTypeFormDto planType)? create,
    TResult? Function(int planTypeId)? delete,
    TResult? Function(int planTypeId, int day)? deletePlanTypeDay,
    TResult? Function(int id)? getPlanType,
    TResult? Function()? getPlanTypes,
    TResult? Function(List<int> dietIds, List<int> workoutIds)?
        getSelectedDietAndWorkoutPlans,
    TResult? Function(PlanTypeFormDto planType)? update,
  }) {
    return create?.call(planType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(PlanTypeFormDto planType)? create,
    TResult Function(int planTypeId)? delete,
    TResult Function(int planTypeId, int day)? deletePlanTypeDay,
    TResult Function(int id)? getPlanType,
    TResult Function()? getPlanTypes,
    TResult Function(List<int> dietIds, List<int> workoutIds)?
        getSelectedDietAndWorkoutPlans,
    TResult Function(PlanTypeFormDto planType)? update,
    required TResult orElse(),
  }) {
    if (create != null) {
      return create(planType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(Create value) create,
    required TResult Function(Delete value) delete,
    required TResult Function(DeletePlanTypeDay value) deletePlanTypeDay,
    required TResult Function(GetPlanType value) getPlanType,
    required TResult Function(GetPlanTypes value) getPlanTypes,
    required TResult Function(GetSelectedDietAndWorkoutPlans value)
        getSelectedDietAndWorkoutPlans,
    required TResult Function(Update value) update,
  }) {
    return create(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(Create value)? create,
    TResult? Function(Delete value)? delete,
    TResult? Function(DeletePlanTypeDay value)? deletePlanTypeDay,
    TResult? Function(GetPlanType value)? getPlanType,
    TResult? Function(GetPlanTypes value)? getPlanTypes,
    TResult? Function(GetSelectedDietAndWorkoutPlans value)?
        getSelectedDietAndWorkoutPlans,
    TResult? Function(Update value)? update,
  }) {
    return create?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(Create value)? create,
    TResult Function(Delete value)? delete,
    TResult Function(DeletePlanTypeDay value)? deletePlanTypeDay,
    TResult Function(GetPlanType value)? getPlanType,
    TResult Function(GetPlanTypes value)? getPlanTypes,
    TResult Function(GetSelectedDietAndWorkoutPlans value)?
        getSelectedDietAndWorkoutPlans,
    TResult Function(Update value)? update,
    required TResult orElse(),
  }) {
    if (create != null) {
      return create(this);
    }
    return orElse();
  }
}

abstract class Create implements PlanTypeEvent {
  const factory Create(final PlanTypeFormDto planType) = _$Create;

  PlanTypeFormDto get planType;
  @JsonKey(ignore: true)
  _$$CreateCopyWith<_$Create> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DeleteCopyWith<$Res> {
  factory _$$DeleteCopyWith(_$Delete value, $Res Function(_$Delete) then) =
      __$$DeleteCopyWithImpl<$Res>;
  @useResult
  $Res call({int planTypeId});
}

/// @nodoc
class __$$DeleteCopyWithImpl<$Res>
    extends _$PlanTypeEventCopyWithImpl<$Res, _$Delete>
    implements _$$DeleteCopyWith<$Res> {
  __$$DeleteCopyWithImpl(_$Delete _value, $Res Function(_$Delete) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? planTypeId = null,
  }) {
    return _then(_$Delete(
      null == planTypeId
          ? _value.planTypeId
          : planTypeId // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Delete implements Delete {
  const _$Delete(this.planTypeId);

  @override
  final int planTypeId;

  @override
  String toString() {
    return 'PlanTypeEvent.delete(planTypeId: $planTypeId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Delete &&
            (identical(other.planTypeId, planTypeId) ||
                other.planTypeId == planTypeId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, planTypeId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteCopyWith<_$Delete> get copyWith =>
      __$$DeleteCopyWithImpl<_$Delete>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(PlanTypeFormDto planType) create,
    required TResult Function(int planTypeId) delete,
    required TResult Function(int planTypeId, int day) deletePlanTypeDay,
    required TResult Function(int id) getPlanType,
    required TResult Function() getPlanTypes,
    required TResult Function(List<int> dietIds, List<int> workoutIds)
        getSelectedDietAndWorkoutPlans,
    required TResult Function(PlanTypeFormDto planType) update,
  }) {
    return delete(planTypeId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(PlanTypeFormDto planType)? create,
    TResult? Function(int planTypeId)? delete,
    TResult? Function(int planTypeId, int day)? deletePlanTypeDay,
    TResult? Function(int id)? getPlanType,
    TResult? Function()? getPlanTypes,
    TResult? Function(List<int> dietIds, List<int> workoutIds)?
        getSelectedDietAndWorkoutPlans,
    TResult? Function(PlanTypeFormDto planType)? update,
  }) {
    return delete?.call(planTypeId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(PlanTypeFormDto planType)? create,
    TResult Function(int planTypeId)? delete,
    TResult Function(int planTypeId, int day)? deletePlanTypeDay,
    TResult Function(int id)? getPlanType,
    TResult Function()? getPlanTypes,
    TResult Function(List<int> dietIds, List<int> workoutIds)?
        getSelectedDietAndWorkoutPlans,
    TResult Function(PlanTypeFormDto planType)? update,
    required TResult orElse(),
  }) {
    if (delete != null) {
      return delete(planTypeId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(Create value) create,
    required TResult Function(Delete value) delete,
    required TResult Function(DeletePlanTypeDay value) deletePlanTypeDay,
    required TResult Function(GetPlanType value) getPlanType,
    required TResult Function(GetPlanTypes value) getPlanTypes,
    required TResult Function(GetSelectedDietAndWorkoutPlans value)
        getSelectedDietAndWorkoutPlans,
    required TResult Function(Update value) update,
  }) {
    return delete(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(Create value)? create,
    TResult? Function(Delete value)? delete,
    TResult? Function(DeletePlanTypeDay value)? deletePlanTypeDay,
    TResult? Function(GetPlanType value)? getPlanType,
    TResult? Function(GetPlanTypes value)? getPlanTypes,
    TResult? Function(GetSelectedDietAndWorkoutPlans value)?
        getSelectedDietAndWorkoutPlans,
    TResult? Function(Update value)? update,
  }) {
    return delete?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(Create value)? create,
    TResult Function(Delete value)? delete,
    TResult Function(DeletePlanTypeDay value)? deletePlanTypeDay,
    TResult Function(GetPlanType value)? getPlanType,
    TResult Function(GetPlanTypes value)? getPlanTypes,
    TResult Function(GetSelectedDietAndWorkoutPlans value)?
        getSelectedDietAndWorkoutPlans,
    TResult Function(Update value)? update,
    required TResult orElse(),
  }) {
    if (delete != null) {
      return delete(this);
    }
    return orElse();
  }
}

abstract class Delete implements PlanTypeEvent {
  const factory Delete(final int planTypeId) = _$Delete;

  int get planTypeId;
  @JsonKey(ignore: true)
  _$$DeleteCopyWith<_$Delete> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DeletePlanTypeDayCopyWith<$Res> {
  factory _$$DeletePlanTypeDayCopyWith(
          _$DeletePlanTypeDay value, $Res Function(_$DeletePlanTypeDay) then) =
      __$$DeletePlanTypeDayCopyWithImpl<$Res>;
  @useResult
  $Res call({int planTypeId, int day});
}

/// @nodoc
class __$$DeletePlanTypeDayCopyWithImpl<$Res>
    extends _$PlanTypeEventCopyWithImpl<$Res, _$DeletePlanTypeDay>
    implements _$$DeletePlanTypeDayCopyWith<$Res> {
  __$$DeletePlanTypeDayCopyWithImpl(
      _$DeletePlanTypeDay _value, $Res Function(_$DeletePlanTypeDay) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? planTypeId = null,
    Object? day = null,
  }) {
    return _then(_$DeletePlanTypeDay(
      null == planTypeId
          ? _value.planTypeId
          : planTypeId // ignore: cast_nullable_to_non_nullable
              as int,
      null == day
          ? _value.day
          : day // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$DeletePlanTypeDay implements DeletePlanTypeDay {
  const _$DeletePlanTypeDay(this.planTypeId, this.day);

  @override
  final int planTypeId;
  @override
  final int day;

  @override
  String toString() {
    return 'PlanTypeEvent.deletePlanTypeDay(planTypeId: $planTypeId, day: $day)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeletePlanTypeDay &&
            (identical(other.planTypeId, planTypeId) ||
                other.planTypeId == planTypeId) &&
            (identical(other.day, day) || other.day == day));
  }

  @override
  int get hashCode => Object.hash(runtimeType, planTypeId, day);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeletePlanTypeDayCopyWith<_$DeletePlanTypeDay> get copyWith =>
      __$$DeletePlanTypeDayCopyWithImpl<_$DeletePlanTypeDay>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(PlanTypeFormDto planType) create,
    required TResult Function(int planTypeId) delete,
    required TResult Function(int planTypeId, int day) deletePlanTypeDay,
    required TResult Function(int id) getPlanType,
    required TResult Function() getPlanTypes,
    required TResult Function(List<int> dietIds, List<int> workoutIds)
        getSelectedDietAndWorkoutPlans,
    required TResult Function(PlanTypeFormDto planType) update,
  }) {
    return deletePlanTypeDay(planTypeId, day);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(PlanTypeFormDto planType)? create,
    TResult? Function(int planTypeId)? delete,
    TResult? Function(int planTypeId, int day)? deletePlanTypeDay,
    TResult? Function(int id)? getPlanType,
    TResult? Function()? getPlanTypes,
    TResult? Function(List<int> dietIds, List<int> workoutIds)?
        getSelectedDietAndWorkoutPlans,
    TResult? Function(PlanTypeFormDto planType)? update,
  }) {
    return deletePlanTypeDay?.call(planTypeId, day);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(PlanTypeFormDto planType)? create,
    TResult Function(int planTypeId)? delete,
    TResult Function(int planTypeId, int day)? deletePlanTypeDay,
    TResult Function(int id)? getPlanType,
    TResult Function()? getPlanTypes,
    TResult Function(List<int> dietIds, List<int> workoutIds)?
        getSelectedDietAndWorkoutPlans,
    TResult Function(PlanTypeFormDto planType)? update,
    required TResult orElse(),
  }) {
    if (deletePlanTypeDay != null) {
      return deletePlanTypeDay(planTypeId, day);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(Create value) create,
    required TResult Function(Delete value) delete,
    required TResult Function(DeletePlanTypeDay value) deletePlanTypeDay,
    required TResult Function(GetPlanType value) getPlanType,
    required TResult Function(GetPlanTypes value) getPlanTypes,
    required TResult Function(GetSelectedDietAndWorkoutPlans value)
        getSelectedDietAndWorkoutPlans,
    required TResult Function(Update value) update,
  }) {
    return deletePlanTypeDay(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(Create value)? create,
    TResult? Function(Delete value)? delete,
    TResult? Function(DeletePlanTypeDay value)? deletePlanTypeDay,
    TResult? Function(GetPlanType value)? getPlanType,
    TResult? Function(GetPlanTypes value)? getPlanTypes,
    TResult? Function(GetSelectedDietAndWorkoutPlans value)?
        getSelectedDietAndWorkoutPlans,
    TResult? Function(Update value)? update,
  }) {
    return deletePlanTypeDay?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(Create value)? create,
    TResult Function(Delete value)? delete,
    TResult Function(DeletePlanTypeDay value)? deletePlanTypeDay,
    TResult Function(GetPlanType value)? getPlanType,
    TResult Function(GetPlanTypes value)? getPlanTypes,
    TResult Function(GetSelectedDietAndWorkoutPlans value)?
        getSelectedDietAndWorkoutPlans,
    TResult Function(Update value)? update,
    required TResult orElse(),
  }) {
    if (deletePlanTypeDay != null) {
      return deletePlanTypeDay(this);
    }
    return orElse();
  }
}

abstract class DeletePlanTypeDay implements PlanTypeEvent {
  const factory DeletePlanTypeDay(final int planTypeId, final int day) =
      _$DeletePlanTypeDay;

  int get planTypeId;
  int get day;
  @JsonKey(ignore: true)
  _$$DeletePlanTypeDayCopyWith<_$DeletePlanTypeDay> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GetPlanTypeCopyWith<$Res> {
  factory _$$GetPlanTypeCopyWith(
          _$GetPlanType value, $Res Function(_$GetPlanType) then) =
      __$$GetPlanTypeCopyWithImpl<$Res>;
  @useResult
  $Res call({int id});
}

/// @nodoc
class __$$GetPlanTypeCopyWithImpl<$Res>
    extends _$PlanTypeEventCopyWithImpl<$Res, _$GetPlanType>
    implements _$$GetPlanTypeCopyWith<$Res> {
  __$$GetPlanTypeCopyWithImpl(
      _$GetPlanType _value, $Res Function(_$GetPlanType) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
  }) {
    return _then(_$GetPlanType(
      null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$GetPlanType implements GetPlanType {
  const _$GetPlanType(this.id);

  @override
  final int id;

  @override
  String toString() {
    return 'PlanTypeEvent.getPlanType(id: $id)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetPlanType &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GetPlanTypeCopyWith<_$GetPlanType> get copyWith =>
      __$$GetPlanTypeCopyWithImpl<_$GetPlanType>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(PlanTypeFormDto planType) create,
    required TResult Function(int planTypeId) delete,
    required TResult Function(int planTypeId, int day) deletePlanTypeDay,
    required TResult Function(int id) getPlanType,
    required TResult Function() getPlanTypes,
    required TResult Function(List<int> dietIds, List<int> workoutIds)
        getSelectedDietAndWorkoutPlans,
    required TResult Function(PlanTypeFormDto planType) update,
  }) {
    return getPlanType(id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(PlanTypeFormDto planType)? create,
    TResult? Function(int planTypeId)? delete,
    TResult? Function(int planTypeId, int day)? deletePlanTypeDay,
    TResult? Function(int id)? getPlanType,
    TResult? Function()? getPlanTypes,
    TResult? Function(List<int> dietIds, List<int> workoutIds)?
        getSelectedDietAndWorkoutPlans,
    TResult? Function(PlanTypeFormDto planType)? update,
  }) {
    return getPlanType?.call(id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(PlanTypeFormDto planType)? create,
    TResult Function(int planTypeId)? delete,
    TResult Function(int planTypeId, int day)? deletePlanTypeDay,
    TResult Function(int id)? getPlanType,
    TResult Function()? getPlanTypes,
    TResult Function(List<int> dietIds, List<int> workoutIds)?
        getSelectedDietAndWorkoutPlans,
    TResult Function(PlanTypeFormDto planType)? update,
    required TResult orElse(),
  }) {
    if (getPlanType != null) {
      return getPlanType(id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(Create value) create,
    required TResult Function(Delete value) delete,
    required TResult Function(DeletePlanTypeDay value) deletePlanTypeDay,
    required TResult Function(GetPlanType value) getPlanType,
    required TResult Function(GetPlanTypes value) getPlanTypes,
    required TResult Function(GetSelectedDietAndWorkoutPlans value)
        getSelectedDietAndWorkoutPlans,
    required TResult Function(Update value) update,
  }) {
    return getPlanType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(Create value)? create,
    TResult? Function(Delete value)? delete,
    TResult? Function(DeletePlanTypeDay value)? deletePlanTypeDay,
    TResult? Function(GetPlanType value)? getPlanType,
    TResult? Function(GetPlanTypes value)? getPlanTypes,
    TResult? Function(GetSelectedDietAndWorkoutPlans value)?
        getSelectedDietAndWorkoutPlans,
    TResult? Function(Update value)? update,
  }) {
    return getPlanType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(Create value)? create,
    TResult Function(Delete value)? delete,
    TResult Function(DeletePlanTypeDay value)? deletePlanTypeDay,
    TResult Function(GetPlanType value)? getPlanType,
    TResult Function(GetPlanTypes value)? getPlanTypes,
    TResult Function(GetSelectedDietAndWorkoutPlans value)?
        getSelectedDietAndWorkoutPlans,
    TResult Function(Update value)? update,
    required TResult orElse(),
  }) {
    if (getPlanType != null) {
      return getPlanType(this);
    }
    return orElse();
  }
}

abstract class GetPlanType implements PlanTypeEvent {
  const factory GetPlanType(final int id) = _$GetPlanType;

  int get id;
  @JsonKey(ignore: true)
  _$$GetPlanTypeCopyWith<_$GetPlanType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GetPlanTypesCopyWith<$Res> {
  factory _$$GetPlanTypesCopyWith(
          _$GetPlanTypes value, $Res Function(_$GetPlanTypes) then) =
      __$$GetPlanTypesCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetPlanTypesCopyWithImpl<$Res>
    extends _$PlanTypeEventCopyWithImpl<$Res, _$GetPlanTypes>
    implements _$$GetPlanTypesCopyWith<$Res> {
  __$$GetPlanTypesCopyWithImpl(
      _$GetPlanTypes _value, $Res Function(_$GetPlanTypes) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GetPlanTypes implements GetPlanTypes {
  const _$GetPlanTypes();

  @override
  String toString() {
    return 'PlanTypeEvent.getPlanTypes()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetPlanTypes);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(PlanTypeFormDto planType) create,
    required TResult Function(int planTypeId) delete,
    required TResult Function(int planTypeId, int day) deletePlanTypeDay,
    required TResult Function(int id) getPlanType,
    required TResult Function() getPlanTypes,
    required TResult Function(List<int> dietIds, List<int> workoutIds)
        getSelectedDietAndWorkoutPlans,
    required TResult Function(PlanTypeFormDto planType) update,
  }) {
    return getPlanTypes();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(PlanTypeFormDto planType)? create,
    TResult? Function(int planTypeId)? delete,
    TResult? Function(int planTypeId, int day)? deletePlanTypeDay,
    TResult? Function(int id)? getPlanType,
    TResult? Function()? getPlanTypes,
    TResult? Function(List<int> dietIds, List<int> workoutIds)?
        getSelectedDietAndWorkoutPlans,
    TResult? Function(PlanTypeFormDto planType)? update,
  }) {
    return getPlanTypes?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(PlanTypeFormDto planType)? create,
    TResult Function(int planTypeId)? delete,
    TResult Function(int planTypeId, int day)? deletePlanTypeDay,
    TResult Function(int id)? getPlanType,
    TResult Function()? getPlanTypes,
    TResult Function(List<int> dietIds, List<int> workoutIds)?
        getSelectedDietAndWorkoutPlans,
    TResult Function(PlanTypeFormDto planType)? update,
    required TResult orElse(),
  }) {
    if (getPlanTypes != null) {
      return getPlanTypes();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(Create value) create,
    required TResult Function(Delete value) delete,
    required TResult Function(DeletePlanTypeDay value) deletePlanTypeDay,
    required TResult Function(GetPlanType value) getPlanType,
    required TResult Function(GetPlanTypes value) getPlanTypes,
    required TResult Function(GetSelectedDietAndWorkoutPlans value)
        getSelectedDietAndWorkoutPlans,
    required TResult Function(Update value) update,
  }) {
    return getPlanTypes(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(Create value)? create,
    TResult? Function(Delete value)? delete,
    TResult? Function(DeletePlanTypeDay value)? deletePlanTypeDay,
    TResult? Function(GetPlanType value)? getPlanType,
    TResult? Function(GetPlanTypes value)? getPlanTypes,
    TResult? Function(GetSelectedDietAndWorkoutPlans value)?
        getSelectedDietAndWorkoutPlans,
    TResult? Function(Update value)? update,
  }) {
    return getPlanTypes?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(Create value)? create,
    TResult Function(Delete value)? delete,
    TResult Function(DeletePlanTypeDay value)? deletePlanTypeDay,
    TResult Function(GetPlanType value)? getPlanType,
    TResult Function(GetPlanTypes value)? getPlanTypes,
    TResult Function(GetSelectedDietAndWorkoutPlans value)?
        getSelectedDietAndWorkoutPlans,
    TResult Function(Update value)? update,
    required TResult orElse(),
  }) {
    if (getPlanTypes != null) {
      return getPlanTypes(this);
    }
    return orElse();
  }
}

abstract class GetPlanTypes implements PlanTypeEvent {
  const factory GetPlanTypes() = _$GetPlanTypes;
}

/// @nodoc
abstract class _$$GetSelectedDietAndWorkoutPlansCopyWith<$Res> {
  factory _$$GetSelectedDietAndWorkoutPlansCopyWith(
          _$GetSelectedDietAndWorkoutPlans value,
          $Res Function(_$GetSelectedDietAndWorkoutPlans) then) =
      __$$GetSelectedDietAndWorkoutPlansCopyWithImpl<$Res>;
  @useResult
  $Res call({List<int> dietIds, List<int> workoutIds});
}

/// @nodoc
class __$$GetSelectedDietAndWorkoutPlansCopyWithImpl<$Res>
    extends _$PlanTypeEventCopyWithImpl<$Res, _$GetSelectedDietAndWorkoutPlans>
    implements _$$GetSelectedDietAndWorkoutPlansCopyWith<$Res> {
  __$$GetSelectedDietAndWorkoutPlansCopyWithImpl(
      _$GetSelectedDietAndWorkoutPlans _value,
      $Res Function(_$GetSelectedDietAndWorkoutPlans) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dietIds = null,
    Object? workoutIds = null,
  }) {
    return _then(_$GetSelectedDietAndWorkoutPlans(
      null == dietIds
          ? _value._dietIds
          : dietIds // ignore: cast_nullable_to_non_nullable
              as List<int>,
      null == workoutIds
          ? _value._workoutIds
          : workoutIds // ignore: cast_nullable_to_non_nullable
              as List<int>,
    ));
  }
}

/// @nodoc

class _$GetSelectedDietAndWorkoutPlans
    implements GetSelectedDietAndWorkoutPlans {
  const _$GetSelectedDietAndWorkoutPlans(
      final List<int> dietIds, final List<int> workoutIds)
      : _dietIds = dietIds,
        _workoutIds = workoutIds;

  final List<int> _dietIds;
  @override
  List<int> get dietIds {
    if (_dietIds is EqualUnmodifiableListView) return _dietIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_dietIds);
  }

  final List<int> _workoutIds;
  @override
  List<int> get workoutIds {
    if (_workoutIds is EqualUnmodifiableListView) return _workoutIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_workoutIds);
  }

  @override
  String toString() {
    return 'PlanTypeEvent.getSelectedDietAndWorkoutPlans(dietIds: $dietIds, workoutIds: $workoutIds)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetSelectedDietAndWorkoutPlans &&
            const DeepCollectionEquality().equals(other._dietIds, _dietIds) &&
            const DeepCollectionEquality()
                .equals(other._workoutIds, _workoutIds));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_dietIds),
      const DeepCollectionEquality().hash(_workoutIds));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GetSelectedDietAndWorkoutPlansCopyWith<_$GetSelectedDietAndWorkoutPlans>
      get copyWith => __$$GetSelectedDietAndWorkoutPlansCopyWithImpl<
          _$GetSelectedDietAndWorkoutPlans>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(PlanTypeFormDto planType) create,
    required TResult Function(int planTypeId) delete,
    required TResult Function(int planTypeId, int day) deletePlanTypeDay,
    required TResult Function(int id) getPlanType,
    required TResult Function() getPlanTypes,
    required TResult Function(List<int> dietIds, List<int> workoutIds)
        getSelectedDietAndWorkoutPlans,
    required TResult Function(PlanTypeFormDto planType) update,
  }) {
    return getSelectedDietAndWorkoutPlans(dietIds, workoutIds);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(PlanTypeFormDto planType)? create,
    TResult? Function(int planTypeId)? delete,
    TResult? Function(int planTypeId, int day)? deletePlanTypeDay,
    TResult? Function(int id)? getPlanType,
    TResult? Function()? getPlanTypes,
    TResult? Function(List<int> dietIds, List<int> workoutIds)?
        getSelectedDietAndWorkoutPlans,
    TResult? Function(PlanTypeFormDto planType)? update,
  }) {
    return getSelectedDietAndWorkoutPlans?.call(dietIds, workoutIds);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(PlanTypeFormDto planType)? create,
    TResult Function(int planTypeId)? delete,
    TResult Function(int planTypeId, int day)? deletePlanTypeDay,
    TResult Function(int id)? getPlanType,
    TResult Function()? getPlanTypes,
    TResult Function(List<int> dietIds, List<int> workoutIds)?
        getSelectedDietAndWorkoutPlans,
    TResult Function(PlanTypeFormDto planType)? update,
    required TResult orElse(),
  }) {
    if (getSelectedDietAndWorkoutPlans != null) {
      return getSelectedDietAndWorkoutPlans(dietIds, workoutIds);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(Create value) create,
    required TResult Function(Delete value) delete,
    required TResult Function(DeletePlanTypeDay value) deletePlanTypeDay,
    required TResult Function(GetPlanType value) getPlanType,
    required TResult Function(GetPlanTypes value) getPlanTypes,
    required TResult Function(GetSelectedDietAndWorkoutPlans value)
        getSelectedDietAndWorkoutPlans,
    required TResult Function(Update value) update,
  }) {
    return getSelectedDietAndWorkoutPlans(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(Create value)? create,
    TResult? Function(Delete value)? delete,
    TResult? Function(DeletePlanTypeDay value)? deletePlanTypeDay,
    TResult? Function(GetPlanType value)? getPlanType,
    TResult? Function(GetPlanTypes value)? getPlanTypes,
    TResult? Function(GetSelectedDietAndWorkoutPlans value)?
        getSelectedDietAndWorkoutPlans,
    TResult? Function(Update value)? update,
  }) {
    return getSelectedDietAndWorkoutPlans?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(Create value)? create,
    TResult Function(Delete value)? delete,
    TResult Function(DeletePlanTypeDay value)? deletePlanTypeDay,
    TResult Function(GetPlanType value)? getPlanType,
    TResult Function(GetPlanTypes value)? getPlanTypes,
    TResult Function(GetSelectedDietAndWorkoutPlans value)?
        getSelectedDietAndWorkoutPlans,
    TResult Function(Update value)? update,
    required TResult orElse(),
  }) {
    if (getSelectedDietAndWorkoutPlans != null) {
      return getSelectedDietAndWorkoutPlans(this);
    }
    return orElse();
  }
}

abstract class GetSelectedDietAndWorkoutPlans implements PlanTypeEvent {
  const factory GetSelectedDietAndWorkoutPlans(
          final List<int> dietIds, final List<int> workoutIds) =
      _$GetSelectedDietAndWorkoutPlans;

  List<int> get dietIds;
  List<int> get workoutIds;
  @JsonKey(ignore: true)
  _$$GetSelectedDietAndWorkoutPlansCopyWith<_$GetSelectedDietAndWorkoutPlans>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateCopyWith<$Res> {
  factory _$$UpdateCopyWith(_$Update value, $Res Function(_$Update) then) =
      __$$UpdateCopyWithImpl<$Res>;
  @useResult
  $Res call({PlanTypeFormDto planType});

  $PlanTypeFormDtoCopyWith<$Res> get planType;
}

/// @nodoc
class __$$UpdateCopyWithImpl<$Res>
    extends _$PlanTypeEventCopyWithImpl<$Res, _$Update>
    implements _$$UpdateCopyWith<$Res> {
  __$$UpdateCopyWithImpl(_$Update _value, $Res Function(_$Update) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? planType = null,
  }) {
    return _then(_$Update(
      null == planType
          ? _value.planType
          : planType // ignore: cast_nullable_to_non_nullable
              as PlanTypeFormDto,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PlanTypeFormDtoCopyWith<$Res> get planType {
    return $PlanTypeFormDtoCopyWith<$Res>(_value.planType, (value) {
      return _then(_value.copyWith(planType: value));
    });
  }
}

/// @nodoc

class _$Update implements Update {
  const _$Update(this.planType);

  @override
  final PlanTypeFormDto planType;

  @override
  String toString() {
    return 'PlanTypeEvent.update(planType: $planType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Update &&
            (identical(other.planType, planType) ||
                other.planType == planType));
  }

  @override
  int get hashCode => Object.hash(runtimeType, planType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateCopyWith<_$Update> get copyWith =>
      __$$UpdateCopyWithImpl<_$Update>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(PlanTypeFormDto planType) create,
    required TResult Function(int planTypeId) delete,
    required TResult Function(int planTypeId, int day) deletePlanTypeDay,
    required TResult Function(int id) getPlanType,
    required TResult Function() getPlanTypes,
    required TResult Function(List<int> dietIds, List<int> workoutIds)
        getSelectedDietAndWorkoutPlans,
    required TResult Function(PlanTypeFormDto planType) update,
  }) {
    return update(planType);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(PlanTypeFormDto planType)? create,
    TResult? Function(int planTypeId)? delete,
    TResult? Function(int planTypeId, int day)? deletePlanTypeDay,
    TResult? Function(int id)? getPlanType,
    TResult? Function()? getPlanTypes,
    TResult? Function(List<int> dietIds, List<int> workoutIds)?
        getSelectedDietAndWorkoutPlans,
    TResult? Function(PlanTypeFormDto planType)? update,
  }) {
    return update?.call(planType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(PlanTypeFormDto planType)? create,
    TResult Function(int planTypeId)? delete,
    TResult Function(int planTypeId, int day)? deletePlanTypeDay,
    TResult Function(int id)? getPlanType,
    TResult Function()? getPlanTypes,
    TResult Function(List<int> dietIds, List<int> workoutIds)?
        getSelectedDietAndWorkoutPlans,
    TResult Function(PlanTypeFormDto planType)? update,
    required TResult orElse(),
  }) {
    if (update != null) {
      return update(planType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(Create value) create,
    required TResult Function(Delete value) delete,
    required TResult Function(DeletePlanTypeDay value) deletePlanTypeDay,
    required TResult Function(GetPlanType value) getPlanType,
    required TResult Function(GetPlanTypes value) getPlanTypes,
    required TResult Function(GetSelectedDietAndWorkoutPlans value)
        getSelectedDietAndWorkoutPlans,
    required TResult Function(Update value) update,
  }) {
    return update(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(Create value)? create,
    TResult? Function(Delete value)? delete,
    TResult? Function(DeletePlanTypeDay value)? deletePlanTypeDay,
    TResult? Function(GetPlanType value)? getPlanType,
    TResult? Function(GetPlanTypes value)? getPlanTypes,
    TResult? Function(GetSelectedDietAndWorkoutPlans value)?
        getSelectedDietAndWorkoutPlans,
    TResult? Function(Update value)? update,
  }) {
    return update?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(Create value)? create,
    TResult Function(Delete value)? delete,
    TResult Function(DeletePlanTypeDay value)? deletePlanTypeDay,
    TResult Function(GetPlanType value)? getPlanType,
    TResult Function(GetPlanTypes value)? getPlanTypes,
    TResult Function(GetSelectedDietAndWorkoutPlans value)?
        getSelectedDietAndWorkoutPlans,
    TResult Function(Update value)? update,
    required TResult orElse(),
  }) {
    if (update != null) {
      return update(this);
    }
    return orElse();
  }
}

abstract class Update implements PlanTypeEvent {
  const factory Update(final PlanTypeFormDto planType) = _$Update;

  PlanTypeFormDto get planType;
  @JsonKey(ignore: true)
  _$$UpdateCopyWith<_$Update> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PlanTypeState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() notLoading,
    required TResult Function(List<PlanTypeDto> plans) listloaded,
    required TResult Function(PlanTypeDto plan) loaded,
    required TResult Function() failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? notLoading,
    TResult? Function(List<PlanTypeDto> plans)? listloaded,
    TResult? Function(PlanTypeDto plan)? loaded,
    TResult? Function()? failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? notLoading,
    TResult Function(List<PlanTypeDto> plans)? listloaded,
    TResult Function(PlanTypeDto plan)? loaded,
    TResult Function()? failure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Loading value) loading,
    required TResult Function(NotLoading value) notLoading,
    required TResult Function(ListLoaded value) listloaded,
    required TResult Function(PlanTypeLoaded value) loaded,
    required TResult Function(Failure value) failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Loading value)? loading,
    TResult? Function(NotLoading value)? notLoading,
    TResult? Function(ListLoaded value)? listloaded,
    TResult? Function(PlanTypeLoaded value)? loaded,
    TResult? Function(Failure value)? failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Loading value)? loading,
    TResult Function(NotLoading value)? notLoading,
    TResult Function(ListLoaded value)? listloaded,
    TResult Function(PlanTypeLoaded value)? loaded,
    TResult Function(Failure value)? failure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PlanTypeStateCopyWith<$Res> {
  factory $PlanTypeStateCopyWith(
          PlanTypeState value, $Res Function(PlanTypeState) then) =
      _$PlanTypeStateCopyWithImpl<$Res, PlanTypeState>;
}

/// @nodoc
class _$PlanTypeStateCopyWithImpl<$Res, $Val extends PlanTypeState>
    implements $PlanTypeStateCopyWith<$Res> {
  _$PlanTypeStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialCopyWith<$Res> {
  factory _$$InitialCopyWith(_$Initial value, $Res Function(_$Initial) then) =
      __$$InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialCopyWithImpl<$Res>
    extends _$PlanTypeStateCopyWithImpl<$Res, _$Initial>
    implements _$$InitialCopyWith<$Res> {
  __$$InitialCopyWithImpl(_$Initial _value, $Res Function(_$Initial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Initial implements Initial {
  const _$Initial();

  @override
  String toString() {
    return 'PlanTypeState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() notLoading,
    required TResult Function(List<PlanTypeDto> plans) listloaded,
    required TResult Function(PlanTypeDto plan) loaded,
    required TResult Function() failure,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? notLoading,
    TResult? Function(List<PlanTypeDto> plans)? listloaded,
    TResult? Function(PlanTypeDto plan)? loaded,
    TResult? Function()? failure,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? notLoading,
    TResult Function(List<PlanTypeDto> plans)? listloaded,
    TResult Function(PlanTypeDto plan)? loaded,
    TResult Function()? failure,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Loading value) loading,
    required TResult Function(NotLoading value) notLoading,
    required TResult Function(ListLoaded value) listloaded,
    required TResult Function(PlanTypeLoaded value) loaded,
    required TResult Function(Failure value) failure,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Loading value)? loading,
    TResult? Function(NotLoading value)? notLoading,
    TResult? Function(ListLoaded value)? listloaded,
    TResult? Function(PlanTypeLoaded value)? loaded,
    TResult? Function(Failure value)? failure,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Loading value)? loading,
    TResult Function(NotLoading value)? notLoading,
    TResult Function(ListLoaded value)? listloaded,
    TResult Function(PlanTypeLoaded value)? loaded,
    TResult Function(Failure value)? failure,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class Initial implements PlanTypeState {
  const factory Initial() = _$Initial;
}

/// @nodoc
abstract class _$$LoadingCopyWith<$Res> {
  factory _$$LoadingCopyWith(_$Loading value, $Res Function(_$Loading) then) =
      __$$LoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingCopyWithImpl<$Res>
    extends _$PlanTypeStateCopyWithImpl<$Res, _$Loading>
    implements _$$LoadingCopyWith<$Res> {
  __$$LoadingCopyWithImpl(_$Loading _value, $Res Function(_$Loading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Loading implements Loading {
  const _$Loading();

  @override
  String toString() {
    return 'PlanTypeState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Loading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() notLoading,
    required TResult Function(List<PlanTypeDto> plans) listloaded,
    required TResult Function(PlanTypeDto plan) loaded,
    required TResult Function() failure,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? notLoading,
    TResult? Function(List<PlanTypeDto> plans)? listloaded,
    TResult? Function(PlanTypeDto plan)? loaded,
    TResult? Function()? failure,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? notLoading,
    TResult Function(List<PlanTypeDto> plans)? listloaded,
    TResult Function(PlanTypeDto plan)? loaded,
    TResult Function()? failure,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Loading value) loading,
    required TResult Function(NotLoading value) notLoading,
    required TResult Function(ListLoaded value) listloaded,
    required TResult Function(PlanTypeLoaded value) loaded,
    required TResult Function(Failure value) failure,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Loading value)? loading,
    TResult? Function(NotLoading value)? notLoading,
    TResult? Function(ListLoaded value)? listloaded,
    TResult? Function(PlanTypeLoaded value)? loaded,
    TResult? Function(Failure value)? failure,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Loading value)? loading,
    TResult Function(NotLoading value)? notLoading,
    TResult Function(ListLoaded value)? listloaded,
    TResult Function(PlanTypeLoaded value)? loaded,
    TResult Function(Failure value)? failure,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class Loading implements PlanTypeState {
  const factory Loading() = _$Loading;
}

/// @nodoc
abstract class _$$NotLoadingCopyWith<$Res> {
  factory _$$NotLoadingCopyWith(
          _$NotLoading value, $Res Function(_$NotLoading) then) =
      __$$NotLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NotLoadingCopyWithImpl<$Res>
    extends _$PlanTypeStateCopyWithImpl<$Res, _$NotLoading>
    implements _$$NotLoadingCopyWith<$Res> {
  __$$NotLoadingCopyWithImpl(
      _$NotLoading _value, $Res Function(_$NotLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NotLoading implements NotLoading {
  const _$NotLoading();

  @override
  String toString() {
    return 'PlanTypeState.notLoading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NotLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() notLoading,
    required TResult Function(List<PlanTypeDto> plans) listloaded,
    required TResult Function(PlanTypeDto plan) loaded,
    required TResult Function() failure,
  }) {
    return notLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? notLoading,
    TResult? Function(List<PlanTypeDto> plans)? listloaded,
    TResult? Function(PlanTypeDto plan)? loaded,
    TResult? Function()? failure,
  }) {
    return notLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? notLoading,
    TResult Function(List<PlanTypeDto> plans)? listloaded,
    TResult Function(PlanTypeDto plan)? loaded,
    TResult Function()? failure,
    required TResult orElse(),
  }) {
    if (notLoading != null) {
      return notLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Loading value) loading,
    required TResult Function(NotLoading value) notLoading,
    required TResult Function(ListLoaded value) listloaded,
    required TResult Function(PlanTypeLoaded value) loaded,
    required TResult Function(Failure value) failure,
  }) {
    return notLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Loading value)? loading,
    TResult? Function(NotLoading value)? notLoading,
    TResult? Function(ListLoaded value)? listloaded,
    TResult? Function(PlanTypeLoaded value)? loaded,
    TResult? Function(Failure value)? failure,
  }) {
    return notLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Loading value)? loading,
    TResult Function(NotLoading value)? notLoading,
    TResult Function(ListLoaded value)? listloaded,
    TResult Function(PlanTypeLoaded value)? loaded,
    TResult Function(Failure value)? failure,
    required TResult orElse(),
  }) {
    if (notLoading != null) {
      return notLoading(this);
    }
    return orElse();
  }
}

abstract class NotLoading implements PlanTypeState {
  const factory NotLoading() = _$NotLoading;
}

/// @nodoc
abstract class _$$ListLoadedCopyWith<$Res> {
  factory _$$ListLoadedCopyWith(
          _$ListLoaded value, $Res Function(_$ListLoaded) then) =
      __$$ListLoadedCopyWithImpl<$Res>;
  @useResult
  $Res call({List<PlanTypeDto> plans});
}

/// @nodoc
class __$$ListLoadedCopyWithImpl<$Res>
    extends _$PlanTypeStateCopyWithImpl<$Res, _$ListLoaded>
    implements _$$ListLoadedCopyWith<$Res> {
  __$$ListLoadedCopyWithImpl(
      _$ListLoaded _value, $Res Function(_$ListLoaded) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? plans = null,
  }) {
    return _then(_$ListLoaded(
      null == plans
          ? _value._plans
          : plans // ignore: cast_nullable_to_non_nullable
              as List<PlanTypeDto>,
    ));
  }
}

/// @nodoc

class _$ListLoaded implements ListLoaded {
  const _$ListLoaded(final List<PlanTypeDto> plans) : _plans = plans;

  final List<PlanTypeDto> _plans;
  @override
  List<PlanTypeDto> get plans {
    if (_plans is EqualUnmodifiableListView) return _plans;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_plans);
  }

  @override
  String toString() {
    return 'PlanTypeState.listloaded(plans: $plans)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListLoaded &&
            const DeepCollectionEquality().equals(other._plans, _plans));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_plans));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListLoadedCopyWith<_$ListLoaded> get copyWith =>
      __$$ListLoadedCopyWithImpl<_$ListLoaded>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() notLoading,
    required TResult Function(List<PlanTypeDto> plans) listloaded,
    required TResult Function(PlanTypeDto plan) loaded,
    required TResult Function() failure,
  }) {
    return listloaded(plans);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? notLoading,
    TResult? Function(List<PlanTypeDto> plans)? listloaded,
    TResult? Function(PlanTypeDto plan)? loaded,
    TResult? Function()? failure,
  }) {
    return listloaded?.call(plans);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? notLoading,
    TResult Function(List<PlanTypeDto> plans)? listloaded,
    TResult Function(PlanTypeDto plan)? loaded,
    TResult Function()? failure,
    required TResult orElse(),
  }) {
    if (listloaded != null) {
      return listloaded(plans);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Loading value) loading,
    required TResult Function(NotLoading value) notLoading,
    required TResult Function(ListLoaded value) listloaded,
    required TResult Function(PlanTypeLoaded value) loaded,
    required TResult Function(Failure value) failure,
  }) {
    return listloaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Loading value)? loading,
    TResult? Function(NotLoading value)? notLoading,
    TResult? Function(ListLoaded value)? listloaded,
    TResult? Function(PlanTypeLoaded value)? loaded,
    TResult? Function(Failure value)? failure,
  }) {
    return listloaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Loading value)? loading,
    TResult Function(NotLoading value)? notLoading,
    TResult Function(ListLoaded value)? listloaded,
    TResult Function(PlanTypeLoaded value)? loaded,
    TResult Function(Failure value)? failure,
    required TResult orElse(),
  }) {
    if (listloaded != null) {
      return listloaded(this);
    }
    return orElse();
  }
}

abstract class ListLoaded implements PlanTypeState {
  const factory ListLoaded(final List<PlanTypeDto> plans) = _$ListLoaded;

  List<PlanTypeDto> get plans;
  @JsonKey(ignore: true)
  _$$ListLoadedCopyWith<_$ListLoaded> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PlanTypeLoadedCopyWith<$Res> {
  factory _$$PlanTypeLoadedCopyWith(
          _$PlanTypeLoaded value, $Res Function(_$PlanTypeLoaded) then) =
      __$$PlanTypeLoadedCopyWithImpl<$Res>;
  @useResult
  $Res call({PlanTypeDto plan});

  $PlanTypeDtoCopyWith<$Res> get plan;
}

/// @nodoc
class __$$PlanTypeLoadedCopyWithImpl<$Res>
    extends _$PlanTypeStateCopyWithImpl<$Res, _$PlanTypeLoaded>
    implements _$$PlanTypeLoadedCopyWith<$Res> {
  __$$PlanTypeLoadedCopyWithImpl(
      _$PlanTypeLoaded _value, $Res Function(_$PlanTypeLoaded) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? plan = null,
  }) {
    return _then(_$PlanTypeLoaded(
      null == plan
          ? _value.plan
          : plan // ignore: cast_nullable_to_non_nullable
              as PlanTypeDto,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PlanTypeDtoCopyWith<$Res> get plan {
    return $PlanTypeDtoCopyWith<$Res>(_value.plan, (value) {
      return _then(_value.copyWith(plan: value));
    });
  }
}

/// @nodoc

class _$PlanTypeLoaded implements PlanTypeLoaded {
  const _$PlanTypeLoaded(this.plan);

  @override
  final PlanTypeDto plan;

  @override
  String toString() {
    return 'PlanTypeState.loaded(plan: $plan)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PlanTypeLoaded &&
            (identical(other.plan, plan) || other.plan == plan));
  }

  @override
  int get hashCode => Object.hash(runtimeType, plan);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PlanTypeLoadedCopyWith<_$PlanTypeLoaded> get copyWith =>
      __$$PlanTypeLoadedCopyWithImpl<_$PlanTypeLoaded>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() notLoading,
    required TResult Function(List<PlanTypeDto> plans) listloaded,
    required TResult Function(PlanTypeDto plan) loaded,
    required TResult Function() failure,
  }) {
    return loaded(plan);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? notLoading,
    TResult? Function(List<PlanTypeDto> plans)? listloaded,
    TResult? Function(PlanTypeDto plan)? loaded,
    TResult? Function()? failure,
  }) {
    return loaded?.call(plan);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? notLoading,
    TResult Function(List<PlanTypeDto> plans)? listloaded,
    TResult Function(PlanTypeDto plan)? loaded,
    TResult Function()? failure,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(plan);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Loading value) loading,
    required TResult Function(NotLoading value) notLoading,
    required TResult Function(ListLoaded value) listloaded,
    required TResult Function(PlanTypeLoaded value) loaded,
    required TResult Function(Failure value) failure,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Loading value)? loading,
    TResult? Function(NotLoading value)? notLoading,
    TResult? Function(ListLoaded value)? listloaded,
    TResult? Function(PlanTypeLoaded value)? loaded,
    TResult? Function(Failure value)? failure,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Loading value)? loading,
    TResult Function(NotLoading value)? notLoading,
    TResult Function(ListLoaded value)? listloaded,
    TResult Function(PlanTypeLoaded value)? loaded,
    TResult Function(Failure value)? failure,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class PlanTypeLoaded implements PlanTypeState {
  const factory PlanTypeLoaded(final PlanTypeDto plan) = _$PlanTypeLoaded;

  PlanTypeDto get plan;
  @JsonKey(ignore: true)
  _$$PlanTypeLoadedCopyWith<_$PlanTypeLoaded> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FailureCopyWith<$Res> {
  factory _$$FailureCopyWith(_$Failure value, $Res Function(_$Failure) then) =
      __$$FailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FailureCopyWithImpl<$Res>
    extends _$PlanTypeStateCopyWithImpl<$Res, _$Failure>
    implements _$$FailureCopyWith<$Res> {
  __$$FailureCopyWithImpl(_$Failure _value, $Res Function(_$Failure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Failure implements Failure {
  const _$Failure();

  @override
  String toString() {
    return 'PlanTypeState.failure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Failure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() notLoading,
    required TResult Function(List<PlanTypeDto> plans) listloaded,
    required TResult Function(PlanTypeDto plan) loaded,
    required TResult Function() failure,
  }) {
    return failure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? notLoading,
    TResult? Function(List<PlanTypeDto> plans)? listloaded,
    TResult? Function(PlanTypeDto plan)? loaded,
    TResult? Function()? failure,
  }) {
    return failure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? notLoading,
    TResult Function(List<PlanTypeDto> plans)? listloaded,
    TResult Function(PlanTypeDto plan)? loaded,
    TResult Function()? failure,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Loading value) loading,
    required TResult Function(NotLoading value) notLoading,
    required TResult Function(ListLoaded value) listloaded,
    required TResult Function(PlanTypeLoaded value) loaded,
    required TResult Function(Failure value) failure,
  }) {
    return failure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Loading value)? loading,
    TResult? Function(NotLoading value)? notLoading,
    TResult? Function(ListLoaded value)? listloaded,
    TResult? Function(PlanTypeLoaded value)? loaded,
    TResult? Function(Failure value)? failure,
  }) {
    return failure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Loading value)? loading,
    TResult Function(NotLoading value)? notLoading,
    TResult Function(ListLoaded value)? listloaded,
    TResult Function(PlanTypeLoaded value)? loaded,
    TResult Function(Failure value)? failure,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(this);
    }
    return orElse();
  }
}

abstract class Failure implements PlanTypeState {
  const factory Failure() = _$Failure;
}
